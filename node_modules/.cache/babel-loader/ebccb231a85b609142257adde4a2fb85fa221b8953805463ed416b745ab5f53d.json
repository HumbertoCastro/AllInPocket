{"ast":null,"code":"import _slicedToArray from \"/home/humberto/all-in-pocket/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nvar LEFT = \"Left\";\nvar RIGHT = \"Right\";\nvar UP = \"Up\";\nvar DOWN = \"Down\";\n\n/* global document */\nvar defaultProps = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: {\n    passive: true\n  }\n};\nvar initialState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0]\n};\nvar mouseMove = \"mousemove\";\nvar mouseUp = \"mouseup\";\nvar touchEnd = \"touchend\";\nvar touchMove = \"touchmove\";\nvar touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n  if (angle === 0) return pos;\n  var angleInRadians = Math.PI / 180 * angle;\n  var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n  var onStart = function onStart(event) {\n    var isTouch = (\"touches\" in event);\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n    set(function (state, props) {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      var _ref = isTouch ? event.touches[0] : event,\n        clientX = _ref.clientX,\n        clientY = _ref.clientY;\n      var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({\n        event: event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        initial: xy.slice(),\n        xy: xy,\n        start: event.timeStamp || 0\n      });\n    });\n  };\n  var onMove = function onMove(event) {\n    set(function (state, props) {\n      var isTouch = (\"touches\" in event);\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? Object.assign(Object.assign({}, state), {\n          swiping: false\n        }) : state;\n      }\n      var _ref2 = isTouch ? event.touches[0] : event,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n      var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),\n        _rotateXYByAngle2 = _slicedToArray(_rotateXYByAngle, 2),\n        x = _rotateXYByAngle2[0],\n        y = _rotateXYByAngle2[1];\n      var deltaX = x - state.xy[0];\n      var deltaY = y - state.xy[1];\n      var absX = Math.abs(deltaX);\n      var absY = Math.abs(deltaY);\n      var time = (event.timeStamp || 0) - state.start;\n      var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      var vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n      var dir = getDirection(absX, absY, deltaX, deltaY);\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      var delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n      var eventData = {\n        absX: absX,\n        absY: absY,\n        deltaX: deltaX,\n        deltaY: deltaY,\n        dir: dir,\n        event: event,\n        first: state.first,\n        initial: state.initial,\n        velocity: velocity,\n        vxvy: vxvy\n      };\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      var cancelablePageSwipe = false;\n      if (props.onSwiping || props.onSwiped || props[\"onSwiped\".concat(dir)]) {\n        cancelablePageSwipe = true;\n      }\n      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {\n        event.preventDefault();\n      }\n      return Object.assign(Object.assign({}, state), {\n        // first is now always false\n        first: false,\n        eventData: eventData,\n        swiping: true\n      });\n    });\n  };\n  var onEnd = function onEnd(event) {\n    set(function (state, props) {\n      var eventData;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = Object.assign(Object.assign({}, state.eventData), {\n            event: event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          var onSwipedDir = props[\"onSwiped\".concat(eventData.dir)];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({\n          event: event\n        });\n      }\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({\n        event: event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        eventData: eventData\n      });\n    });\n  };\n  var cleanUpMouse = function cleanUpMouse() {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n  var onUp = function onUp(e) {\n    cleanUpMouse();\n    onEnd(e);\n  };\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  var attachTouch = function attachTouch(el, props) {\n    var cleanup = function cleanup() {};\n    if (el && el.addEventListener) {\n      var baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n      // attach touch event listeners and handlers\n      var tls = [[touchStart, onStart, baseOptions],\n      // preventScrollOnSwipe option supersedes touchEventOptions.passive\n      [touchMove, onMove, Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {\n        passive: false\n      } : {})], [touchEnd, onEnd, baseOptions]];\n      tls.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 3),\n          e = _ref4[0],\n          h = _ref4[1],\n          o = _ref4[2];\n        return el.addEventListener(e, h, o);\n      });\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = function cleanup() {\n        return tls.forEach(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n            e = _ref6[0],\n            h = _ref6[1];\n          return el.removeEventListener(e, h);\n        });\n      };\n    }\n    return cleanup;\n  };\n  var onRef = function onRef(el) {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set(function (state, props) {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n      var addState = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return Object.assign(Object.assign(Object.assign({}, state), {\n        el: el\n      }), addState);\n    });\n  };\n  // set ref callback to attach touch event listeners\n  var output = {\n    ref: onRef\n  };\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n  return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: undefined\n    });\n  }\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n    state.cleanUpTouch();\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n  return state;\n}\nfunction useSwipeable(options) {\n  var trackMouse = options.trackMouse;\n  var transientState = React.useRef(Object.assign({}, initialState));\n  var transientProps = React.useRef(Object.assign({}, defaultProps));\n  // track previous rendered props\n  var previousProps = React.useRef(Object.assign({}, transientProps.current));\n  previousProps.current = Object.assign({}, transientProps.current);\n  // update current render props & defaults\n  transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n  // Force defaults for config properties\n  var defaultKey;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      transientProps.current[defaultKey] = defaultProps[defaultKey];\n    }\n  }\n  var _React$useMemo = React.useMemo(function () {\n      return getHandlers(function (stateSetter) {\n        return transientState.current = stateSetter(transientState.current, transientProps.current);\n      }, {\n        trackMouse: trackMouse\n      });\n    }, [trackMouse]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n    handlers = _React$useMemo2[0],\n    attachTouch = _React$useMemo2[1];\n  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n  return handlers;\n}\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };","map":{"version":3,"names":["LEFT","RIGHT","UP","DOWN","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","touchEnd","touchMove","touchStart","getDirection","absX","absY","deltaX","deltaY","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","x","cos","sin","y","getHandlers","set","handlerProps","onStart","event","isTouch","touches","length","state","props","document","addEventListener","onMove","onUp","_ref","clientX","clientY","onTouchStartOrOnMouseDown","Object","assign","slice","timeStamp","_ref2","_rotateXYByAngle","_rotateXYByAngle2","_slicedToArray","abs","time","velocity","sqrt","vxvy","dir","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","concat","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","cleanUpMouse","removeEventListener","e","attachTouch","el","cleanup","baseOptions","tls","forEach","_ref3","_ref4","h","o","_ref5","_ref6","onRef","addState","cleanUpTouch","output","ref","onMouseDown","updateTransientState","previousProps","undefined","useSwipeable","options","transientState","React","useRef","transientProps","current","defaultKey","_React$useMemo","useMemo","stateSetter","_React$useMemo2","handlers"],"sources":["/home/humberto/all-in-pocket/node_modules/react-swipeable/src/types.ts","/home/humberto/all-in-pocket/node_modules/react-swipeable/src/index.ts"],"sourcesContent":["import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  /**\n   * Absolute displacement of swipe in x. Math.abs(deltaX);\n   */\n  absX: number;\n  /**\n   * Absolute displacement of swipe in y. Math.abs(deltaY);\n   */\n  absY: number;\n  /**\n   * Displacement of swipe in x. (current.x - initial.x)\n   */\n  deltaX: number;\n  /**\n   * Displacement of swipe in y. (current.y - initial.y)\n   */\n  deltaY: number;\n  /**\n   * Direction of swipe - Left | Right | Up | Down\n   */\n  dir: SwipeDirections;\n  /**\n   * Source event.\n   */\n  event: HandledEvents;\n  /**\n   * True for the first event of a tracked swipe.\n   */\n  first: boolean;\n  /**\n   * Location where swipe started - [x, y].\n   */\n  initial: Vector2;\n  /**\n   * \"Absolute velocity\" (speed) - âˆš(absX^2 + absY^2) / time\n   */\n  velocity: number;\n  /**\n   * Velocity per axis - [ deltaX/time, deltaY/time ]\n   */\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableDirectionCallbacks = {\n  /**\n   * Called after a DOWN swipe\n   */\n  onSwipedDown: SwipeCallback;\n  /**\n   * Called after a LEFT swipe\n   */\n  onSwipedLeft: SwipeCallback;\n  /**\n   * Called after a RIGHT swipe\n   */\n  onSwipedRight: SwipeCallback;\n  /**\n   * Called after a UP swipe\n   */\n  onSwipedUp: SwipeCallback;\n};\n\nexport type SwipeableCallbacks = SwipeableDirectionCallbacks & {\n  /**\n   * Called at start of a tracked swipe.\n   */\n  onSwipeStart: SwipeCallback;\n  /**\n   * Called after any swipe.\n   */\n  onSwiped: SwipeCallback;\n  /**\n   * Called for each move event during a tracked swipe.\n   */\n  onSwiping: SwipeCallback;\n  /**\n   * Called after a tap. A touch under the min distance, `delta`.\n   */\n  onTap: TapCallback;\n  /**\n   * Called for `touchstart` and `mousedown`.\n   */\n  onTouchStartOrOnMouseDown: TapCallback;\n  /**\n   * Called for `touchend` and `mouseup`.\n   */\n  onTouchEndOrOnMouseUp: TapCallback;\n};\n\n// Configuration Options\nexport type ConfigurationOptionDelta =\n  | number\n  | { [key in Lowercase<SwipeDirections>]?: number };\n\nexport interface ConfigurationOptions {\n  /**\n   * Min distance(px) before a swipe starts. **Default**: `10`\n   */\n  delta: ConfigurationOptionDelta;\n  /**\n   * Prevents scroll during swipe in most cases. **Default**: `false`\n   */\n  preventScrollOnSwipe: boolean;\n  /**\n   * Set a rotation angle. **Default**: `0`\n   */\n  rotationAngle: number;\n  /**\n   * Track mouse input. **Default**: `false`\n   */\n  trackMouse: boolean;\n  /**\n   * Track touch input. **Default**: `true`\n   */\n  trackTouch: boolean;\n  /**\n   * Allowable duration of a swipe (ms). **Default**: `Infinity`\n   */\n  swipeDuration: number;\n  /**\n   * Options for touch event listeners\n   */\n  touchEventOptions: { passive: boolean };\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (\n  el: HTMLElement,\n  props: SwipeablePropsWithDefaultOptions\n) => () => void;\n","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  ConfigurationOptions,\n  SwipeableDirectionCallbacks,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeableDirectionCallbacks,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps: ConfigurationOptions = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: { passive: true },\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    const isTouch = \"touches\" in event;\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n\n      props.onTouchStartOrOnMouseDown &&\n        props.onTouchStartOrOnMouseDown({ event });\n\n      return {\n        ...state,\n        ...initialState,\n        initial: xy.slice() as Vector2,\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      const isTouch = \"touches\" in event;\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? { ...state, swiping: false } : state;\n      }\n\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      const delta =\n        typeof props.delta === \"number\"\n          ? props.delta\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\n            defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (\n        props.onSwiping ||\n        props.onSwiped ||\n        props[`onSwiped${dir}` as keyof SwipeableDirectionCallbacks]\n      ) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventScrollOnSwipe &&\n        props.trackTouch &&\n        event.cancelable\n      ) {\n        event.preventDefault();\n      }\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = { ...state.eventData, event };\n          props.onSwiped && props.onSwiped(eventData);\n\n          const onSwipedDir =\n            props[\n              `onSwiped${eventData.dir}` as keyof SwipeableDirectionCallbacks\n            ];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  const attachTouch: AttachTouch = (el, props) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      const baseOptions = {\n        ...defaultProps.touchEventOptions,\n        ...props.touchEventOptions,\n      };\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void,\n        { passive: boolean }\n      ][] = [\n        [touchStart, onStart, baseOptions],\n        // preventScrollOnSwipe option supersedes touchEventOptions.passive\n        [\n          touchMove,\n          onMove,\n          {\n            ...baseOptions,\n            ...(props.preventScrollOnSwipe ? { passive: false } : {}),\n          },\n        ],\n        [touchEnd, onEnd, baseOptions],\n      ];\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions,\n  previousProps: SwipeablePropsWithDefaultOptions,\n  attachTouch: AttachTouch\n) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return {\n      ...state,\n      cleanUpTouch: undefined,\n    };\n  }\n\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (\n    props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n    props.touchEventOptions.passive !== previousProps.touchEventOptions.passive\n  ) {\n    state.cleanUpTouch();\n\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  return state;\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n\n  // track previous rendered props\n  const previousProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...transientProps.current,\n  });\n  previousProps.current = { ...transientProps.current };\n\n  // update current render props & defaults\n  transientProps.current = {\n    ...defaultProps,\n    ...options,\n  };\n  // Force defaults for config properties\n  let defaultKey: keyof ConfigurationOptions;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      (transientProps.current[defaultKey] as any) = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    previousProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}